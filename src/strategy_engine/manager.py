from typing import Dict, Any, Optional, List, Type
import logging
from datetime import datetime
from .base_strategy import BaseStrategy
from .models import Signal, StrategyState, DataPoint
from ..trading_engine.engine import TradingEngine

logger = logging.getLogger(__name__)


class StrategyManager:
    def __init__(
        self,
        trading_engine: TradingEngine,
        state_manager: Any,
        config: Dict[str, Any]
    ):
        self.trading_engine = trading_engine
        self.state_manager = state_manager
        self.config = config
        self.strategies: Dict[str, BaseStrategy] = {}
        self.active_symbols: set = set()

    async def add_strategy(
        self,
        strategy_id: str,
        strategy_class: Type[BaseStrategy],
        symbol: str,
        params: Dict[str, Any]
    ) -> None:
        """Add a new strategy instance"""
        try:
            if strategy_id in self.strategies:
                raise ValueError(f"Strategy already exists: {strategy_id}")

            strategy = strategy_class(
                strategy_id=strategy_id,
                symbol=symbol,
                params=params,
                state_manager=self.state_manager
            )

            await strategy.initialize()
            self.strategies[strategy_id] = strategy
            self.active_symbols.add(symbol)

            logger.info(f"Strategy added successfully: {strategy_id}")

        except Exception as e:
            logger.error(f"Error adding strategy: {str(e)}")
            raise

    async def remove_strategy(self, strategy_id: str) -> None:
        """Remove a strategy instance"""
        try:
            if strategy_id not in self.strategies:
                raise ValueError(f"Strategy not found: {strategy_id}")

            strategy = self.strategies[strategy_id]
            symbol = strategy.symbol

            # Close any open positions
            state = await strategy.get_state()
            if state and state.current_position:
                try:
                    await self.trading_engine.close_position(
                        position_id=state.current_position,
                        metadata={"reason": "strategy_removed"}
                    )
                except Exception as e:
                    logger.error(f"Error closing position: {str(e)}")

            # Remove strategy
            del self.strategies[strategy_id]

            # Update active symbols
            if not any(s.symbol == symbol for s in self.strategies.values()):
                self.active_symbols.remove(symbol)

            logger.info(f"Strategy removed successfully: {strategy_id}")

        except Exception as e:
            logger.error(f"Error removing strategy: {str(e)}")
            raise

    async def process_data(self, data_point: DataPoint) -> None:
        """Process new data point across relevant strategies"""
        try:
            for strategy in self.strategies.values():
                if strategy.symbol == data_point.symbol:
                    # Update positions with current price if it's a price update
                    if data_point.data_type == "price":
                        await self.trading_engine.update_positions(
                            symbol=data_point.symbol,
                            current_price=data_point.value
                        )

                    # Process data in strategy
                    signals = await strategy.process_data(data_point)
                    if signals:
                        await self._handle_signals(signals)

        except Exception as e:
            logger.error(f"Error processing data: {str(e)}")
            raise

    async def _handle_signals(self, signals: List[Signal]) -> None:
        """Handle signals generated by strategies"""
        for signal in signals:
            try:
                strategy = self.strategies.get(signal.strategy_id)
                if not strategy:
                    logger.warning(
                        f"Strategy not found for signal: {signal.strategy_id}")
                    continue

                state = await strategy.get_state()
                if not state:
                    logger.warning(
                        f"Strategy state not found: {signal.strategy_id}")
                    continue

                # Handle signal based on current position
                if signal.signal_type == "entry":
                    if state.current_position:
                        logger.warning(
                            f"Position already exists for strategy: {signal.strategy_id}")
                        continue

                    # Execute market order
                    order = await self.trading_engine.execute_market_order(
                        symbol=signal.symbol,
                        side=signal.side,
                        size=signal.size,
                        stop_loss=signal.metadata.get("stop_loss"),
                        metadata={
                            "strategy_id": signal.strategy_id,
                            "signal_type": signal.signal_type,
                            "confidence": signal.confidence
                        }
                    )

                    # Update strategy state with new position
                    await strategy.update_state(
                        position_id=order.position_id,
                        position_size=signal.size,
                        metadata=signal.metadata
                    )

                elif signal.signal_type == "exit":
                    if not state.current_position:
                        logger.warning(
                            f"No position exists for strategy: {signal.strategy_id}")
                        continue

                    # Close position
                    await self.trading_engine.close_position(
                        position_id=state.current_position,
                        metadata={
                            "strategy_id": signal.strategy_id,
                            "signal_type": signal.signal_type,
                            "confidence": signal.confidence
                        }
                    )

                    # Update strategy state
                    await strategy.update_state(
                        position_id=None,
                        position_size=0,
                        metadata=signal.metadata
                    )

            except Exception as e:
                logger.error(f"Error handling signal: {str(e)}")

    async def get_strategy_summary(self) -> Dict[str, Any]:
        """Get summary of all strategies"""
        try:
            summaries = []
            for strategy_id, strategy in self.strategies.items():
                state = await strategy.get_state()
                if not state:
                    continue

                summaries.append({
                    "strategy_id": strategy_id,
                    "symbol": strategy.symbol,
                    "active": state.active,
                    "position_size": state.position_size,
                    "current_position": state.current_position,
                    "last_update": state.last_update.isoformat() if state.last_update else None,
                    "metadata": state.metadata
                })

            return {
                "total_strategies": len(self.strategies),
                "active_symbols": list(self.active_symbols),
                "strategies": summaries
            }

        except Exception as e:
            logger.error(f"Error getting strategy summary: {str(e)}")
            raise
